<#
.Synopsis
   This script will backup all Virtual Machine(s) on Hyper-V and store them onto a network or local drive.
.DESCRIPTION
   This script is intended to run as a Windows scheduled task. There are no arguments that need to be passed as a command, simply run this script with no arguments. 
   This script must be ran as an Administrator of the local Hyper-V host machine. Make sure that the Admin user has access to the remote or local disk where the backups will be stored.
   The script will create a Shadow Copy of the Volume where the virtual machines exist. It will then start copying the virtual machines to the network storage (example:\\SERVER01\I$\VirtaulMachineBackup).
   Backups will be stored in a folder named after the hostname with a date appended to it "[Hostname][Date]". This script will also create a backup of the .xml files necessary for recovering a Virtual Machine.
   
   This script assumes you have all of your Virtual Machine disks on the D: drive.
   
   EDITING SETTINGS ON NOTEPAD:
   
   BackupDestinationPath -    This variable is a path to the storage destination. You can set it to whatever local or network path you'd like.
   
   NumberofBackupsToKeep -    This variable specifies how many recent virtual machine backups to keep. By default, it will only keep the 3 most recent backups. Set this value to any POSITIVE integer
   and make sure you have enough space on your storage unit to hold these backups. Virtual machine disks can be quite large.
      
#>



#********* This script will create a shadow copy of drive D: Then it will backup the virtual machine disks within D: to a network storage************


#**********************************************************Configurable settings*********************************************************************

#Specify the destination for backups to be saved to. A folder named after the hostname of this machine will be created.
$BackupDestinationPath = "\\SERVER01\I$\VirtaulMachineBackup"

#Specify the number of VM backups that should be kept. This program will only keep the latest N number of backups
$NumberofBackupsToKeep = 3

#*****************************************************************************************************************************************************


#clear out any errors
$error.clear()

#These variables store any error messages generated by the script.
$endMessage = " "
$result = "SUCCESS"

#Check if a directory named as the hostname (SERVER01, SERVER02, etc.) already exists. Create a directory if it doesn't exist.
If (-Not (Test-Path $BackupDestinationPath\$env:computername)){
	New-Item -ItemType Directory -Path $BackupDestinationPath\$env:computername -Force
}


#Updates "Backup Destination path" variable to include a directory named after the hostname.
$BackupDestinationPath = "$BackupDestinationPath\$env:computername"


#HostNameAndDate variable holds the name of the host machine as well as the current date.
$HostNameAndDate = Get-Date
$HostNameAndDate = $HostNameAndDate.ToString('_MM-dd-yyyy')
$HostNameAndDate = $env:computername + $HostNameAndDate


#Create folder named as the hostname and date inside the destination directory
if(Test-Path $BackupDestinationPath\$HostNameAndDate){
Remove-Item -Path $BackupDestinationPath\$HostNameAndDate -Force -Recurse
}
Write-Host "Creating new directory on " $BackupDestinationPath
New-Item -ItemType Directory -Path $BackupDestinationPath\$HostNameAndDate\Configuration -Force

if ( $? -eq $True ) {
    Write-Host "SUCCESS" -ForegroundColor Green
}


Write-Host " "
Write-Host " "

#Create a shadow copy of the volume D: and assign output values to an array called $string
Write-Host "Creating Shadow copy of volume D:"
$string = vssadmin create shadow /for=D: | Select-String 'Shadow Copy ID', 'Shadow Copy Volume'

if ( $? -eq $True ) {
    Write-Host "SUCCESS" -ForegroundColor Green
}


Write-Host " "
Write-Host " "


#format $id and $volume. They are elements of $string
$id = ($string[0] -split 'ID:')[1].trim()

$Volume = ($string[1] -split 'Name:')[1].trim()
$volume = $volume + "\"


#create a symbolic link in D:\ called "vssvolume". This links a generic directory in root with the actual location of the shadow copy.
Write-Host "Creating symbolic link"
cmd /c mklink /d D:\vssvolume $volume

if ($LASTEXITCODE -eq 0) {
    Write-Host "SUCCESS" -ForegroundColor Green
}

Write-Host " "
Write-Host " "



#This line of code will get the names of all virtual machines on this local virtual machine host.
$output = Get-WmiObject -Class Msvm_ComputerSystem -Namespace "root\virtualization" | ? {$_.Caption -eq "Virtual Machine" }


if ( $? -eq $True ) {
    Write-Host "SUCCESS" -ForegroundColor Green
}

Write-Host " "
Write-Host " "

#Loop through every virtual machine
Foreach ($ElementName in $output){

#recursivley seach for xml configuration file that belongs to current $ElementName.ElementName
$xmlFileName = $ElementName.name
$configxml = get-childitem "D:\" -recurse | where {$_.name -eq "$xmlFileName.xml"} | where {$_.FullName -notlike "*\vssvolume\*"}
$xmlFilePath = $configxml.FullName

#Reads the xml configuration file of the Virtual Machine and gets the full path to the Virtual Machine .VHD file as a string.
[xml]$xmlFile = Get-Content -Path $xmlFilePath
$xmlFile.GetType().FullNameSystem.Xml.xmlFile

$vhdLocation = $xmlFile.configuration."_83f8638b-8dca-4152-9eda-2ca8b33039b4_".controller0.drive0.pathname.'#text'
$vhdLocation = $vhdLocation.Substring(2)
$vhdLocation = "D:\vssvolume" + $vhdLocation

write-host "Backing up .xml file for " $ElementName.ElementName

Copy-Item -Path "$xmlFilePath" -Destination "$BackupDestinationPath\$HostNameAndDate\Configuration" -recurse -Force -Verbose -Confirm:$false

if ( $? -eq $True ) {
    Write-Host "SUCCESS" -ForegroundColor Green
}

write-host " "
write-host "$vhdLocation"

write-host "Backing up virtual disk for: " $ElementName.ElementName
Copy-Item -Path "$vhdLocation" -Destination "$BackupDestinationPath\$HostNameAndDate" -recurse -Force -Verbose -Confirm:$false

if ( $? -eq $True ) {
    Write-Host "SUCCESS" -ForegroundColor Green
}

Write-Host " "
Write-Host " "



}

Write-Host "Removing symbolic link and directory: D:\vssvolume"
cmd /c rmdir D:\vssvolume

if ( $LASTEXITCODE -eq 0 ) {
    Write-Host "SUCCESS" -ForegroundColor Green
}

Write-Host " "
Write-Host " "

Write-Host "Removing shadow copy"
vssadmin delete shadows /shadow=$id /quiet

if ( $? -eq $True ) {
    Write-Host "SUCCESS" -ForegroundColor Green
}

Write-Host " "
Write-Host " "


#This variable is used to determine how many total backups are in the root folder of the backup directory
$NumberOfFolders = Get-ChildItem -Path $BackupDestinationPath

#If the number of backups is greater than the amount we want to keep, then we will delete the oldest backup.
if($NumberOfFolders.Count -gt $NumberofBackupsToKeep){
Write-Host "Keeping the" $NumberofBackupsToKeep "most recent backups"
$RootFolder = Get-ChildItem -Path $BackupDestinationPath | Sort-Object LastWriteTime | Select-Object -First ($NumberOfFolders.Count - $NumberofBackupsToKeep)
	forEach ($ChildFolder in $RootFolder){
	Write-Host "Removing " $ChildFolder
	Remove-Item -Path $BackupDestinationPath\$ChildFolder -Force -Recurse
	if ( $? -eq $True ) {
		Write-Host "SUCCESS" -ForegroundColor Green
		}
	}
}



if($error.count -gt 0){
	$result = "ERRORS"

	forEach ($elem in $error){
	
		$endMessage += "ERROR DETAILS: $elem"
		$endMessage += "`n"
		$endMessage += "`n"
	
		
	}
}


write-host $endMessage



#* =========================
#* SMTP Mail Alert
#* =========================

Send-MailMessage -To “Manager 1 <example@example.com>" -From “Reports Admin <example@example.com>" -SMTPServer gwsmtp.usa.net -Subject “Virtual Machine backups on $env:computername [$result]” -Body “Backup of VHD Files and configuration files can be found in: $BackupDestinationPath\$HostNameAndDate `n `n $endMessage”


